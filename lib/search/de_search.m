function [best_parameters, best_err, all_p, all_e] = de_search(func, ranges, varargin);
%DE_SEARCH   Lightweight differential evolution.
%
%  Runs a differential evolution algorithm. Updated results are
%  not saved after each generation. Designed for searches that run
%  relatively quickly.
%
%  [best_parameters, best_err] = de_search(func, ranges, ...)
%
%  INPUTS:
%        func:  function handle to a function of the form:
%                error = func(params, ...)
%
%      ranges:  [2 X params] matrix, where ranges(1,i) and ranges(2,i)
%               give the lower and upper bounds, respectively, for
%               parameter i.
%
%  OUTPUT:
%  best_parameters:  [1 X params] vector of the best-fitting parameter
%                    values.
%
%         best_err:  Error for the best-fitting parameter set.
%
%  OPTIONS:
%  These options may be specified using parameter, value pairs or by
%  passing a structure. Defaults are shown in parentheses.
%   popsize         - total number of individuals. (100)
%   generations     - generations to run. (10)
%   strategy        - mutation strategy (see MUTATE for options) (2)
%   step_weight     - stepsize weight (between 0 and 2) to apply to
%                     differentials when mutating parameters (0.85)
%   crossover       - crossover probability constant (between 0 and
%                     1).  Percentage of random new mutated
%                     parameters to use in the new population (1)
%   range_bound     - boolean indicating whether parameters are
%                     strictly bound by the values in ranges (true)
%   init_ranges     - ranges for initial parameter generation. ([])
%   init_parameters - initial parameter set. Additiaonal individuals
%                     will be generated by adding normally distributed
%                     noise. ([])
%   init_scale      - standard deviation of added noise, relative to
%                     the init_range for each parameter. (.1)
%   tol             - if change between generations drops below this,
%                     search is terminated. (0.000001)
%   stall_gen_limit - number of generations to evaluate the tolerance
%                     over (50)
%
%  See also run_de_dce, mutate.

% set options
def.popsize = 50;
def.generations = 200;
def.strategy = 2;
def.step_weight = 0.85;
def.crossover = 1;
def.range_bound = 1;
def.init_ranges = ranges;
def.init_parameters = [];
def.init_scale = .1;
def.tol = .000001;
def.stall_gen_limit = 50;
def.save_all = false;
def.mutate_func = @mutate;
def.plot_func = [];
def.verbose = 2;
def.eval_all = false;
opt = propval(varargin, def);

num_params = size(ranges, 2);

% create initial parameter list
if opt.verbose >= 1
    fprintf('Creating %d random individuals...\n', opt.popsize)
end

% random creation of the initial parameter set
if ~isempty(opt.init_parameters)
    parameters = NaN(opt.popsize, num_params);
    for i = 1:opt.popsize
        parameters(i,:) = opt.init_parameters + ...
            randn(1, num_params) .* opt.init_scale .* diff(opt.init_ranges, [], 1);
    end
    parameters(1,:) = opt.init_parameters;
else
    parameters = rand(opt.popsize, num_params);

    % modify these to be within the appropriate ranges
    % first multiply each by the difference between the min and max
    % of the ranges, then add the min range
    diffs = repmat(diff(opt.init_ranges), [opt.popsize 1]);
    mins = repmat(opt.init_ranges(1,:), [opt.popsize 1]);
    parameters = (parameters .* diffs) + mins;
end

% initialize params and fitness such that the "new" initialized
% parameter set always wins
prev_parameters = parameters;
prev_err = Inf(size(parameters, 1), 1);
err = NaN(size(parameters, 1), 1);
err_all = NaN(opt.generations, 1);
all_p = cell(1, opt.generations);
all_e = cell(1, opt.generations);
global_best = Inf;
global_parameters = [];
% for loop over generations
for gen = 1:opt.generations
    % submit the job set
    if opt.verbose >= 2
        fprintf('Generation %4d    ', gen)
    end

    if opt.eval_all
        err = func(parameters);
    else
        for i = 1:size(parameters, 1)
            err(i) = func(parameters(i,:));
        end
    end

    if opt.save_all
        all_p{gen} = parameters;
        all_e{gen} = err;
    end
    if any(err == 0)
        err(err == 0) = 1e10;
    end
    if any(isnan(err))
        err(isnan(err)) = 1e10;
    end
    if any(isinf(err))
        err(isinf(err)) = 1e10;
    end
    
    % metropolis-hastings: sometimes choose a point even when it's a
    % little worse
    if gen > 1
        a = -err + prev_err;
        move = a > log(rand(size(a)));
        err(~move,:) = prev_err(~move,:);
        parameters(~move,:) = prev_parameters(~move,:);
    end

    if ~isempty(opt.plot_func)
        opt.plot_func(parameters);
        drawnow
    end
    
    % find best fitness
    [best_err, best_ind] = min(err);
    best_parameters = parameters(best_ind,:);
    if best_err < global_best
        global_best = best_err;
        global_parameters = best_parameters;
    end
    err_all(gen) = global_best;

    if opt.verbose >= 2
        fprintf('Median %10g    Min %10g\n', median(err), global_best)
    end
    
    % check whether to terminate the search
    if gen > opt.stall_gen_limit
        change = err_all(gen - opt.stall_gen_limit) - global_best;
        if change < opt.tol
            if opt.verbose >= 1
                fprintf(['Change of less than %g over last %d generations. ' ...
                         'Terminating...\n'], opt.tol, opt.stall_gen_limit);
            end
            return
        end
    end
    
    % mutate
    if gen < opt.generations
        % hold on to previous generation
        prev_err = err;
        prev_parameters = parameters;
        
        % pass them into the mutate function, get back pop size
        % parameters
        parameters = opt.mutate_func(parameters, err, ranges, opt.strategy, ...
                                     opt.step_weight, opt.crossover, opt.range_bound);
    else
        fprintf('Warning: Ran maximum number of generations %d. Terminating...\n', ...
                opt.generations);
    end
end
